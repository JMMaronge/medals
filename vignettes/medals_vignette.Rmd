---
title: "medals Vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{medals Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

Hi everyone! The purpose of this vignette is to give an easy to understand tutorial on how to use my new package, medals! As you may know, my package is available [here](https://github.com/JMMaronge/medals). medals is a R package to implement a new method I've been working on for lesion segmentation, which I'm calling MEDALS: Memory Efficient Decomposition for Analysis of Local neighborhood moments for Segmentation.  

For this vignette, we will use the medals package to train on two subjects with multimodal MRI (T1w, T2w, FLAIR, DWI).  Every subject's image is skull-stripped coregistered to the FLAIR, and smoothed. Then every image is normalized using a trimmed normalization. We will analyze up to the 4th order moment image. Then we will test the fitting on a separate subject.

Before doing anything, we need to get our data in a particular form. We need a list of paths to MRI images, a list of paths to brain masks, and a list of paths to manual segmentations.  Below I show the structure of these lists. Images are denoted by image.file, brain masks by mask.file and manual segmentations by y.file. Notice that image.file is a list of sublists, each sublist is a list of imaging sequences for a particular subject. The orders of image.file, mask.file, and y.file should all match.

```{r, echo=FALSE}
dir<-"~/Desktop/images_ISLES2015/training/"
subj<-c("05","06")

image.file<-vector(length = length(subj), mode = "list")
mask.file<-vector(length = length(subj), mode = "list")
y.file<-vector(length = length(subj), mode = "list")

for(i in 1:length(subj)){
image.file[[i]][[1]]<-paste0(dir,"flairTrimmedNormImg_Subject",subj[i],".nii.gz") 
image.file[[i]][[2]]<-paste0(dir,"t1TrimmedNormImg_Subject",subj[i],".nii.gz") 
image.file[[i]][[3]]<-paste0(dir,"t2TrimmedNormImg_Subject",subj[i],".nii.gz") 
image.file[[i]][[4]]<-paste0(dir,"dwiTrimmedNormImg_Subject",subj[i],".nii.gz") 
mask.file[[i]]<-paste0(dir,"brainmask_Subject",subj[i],".nii.gz")
y.file[[i]]<-paste0(dir,"ymask_Subject",subj[i],".nii.gz")
}
```

```{r,echo=TRUE}
print(image.file)
print(mask.file)
print(y.file)
```

The first thing we need to do is center and scale the columns of the matrix we want to perform PCA on. To do this, we will get the column mean and standard deviation for each column. This is done by using imaging.suff.stat(), as shown below

```{r,echo=TRUE,cache=TRUE}
#### library(devtools) ### for install_github()
#### install_github("jmmaronge/medals") ### installing medals
library(medals)
path.img.list = image.file
path.mask.list = mask.file
mpower = 3
suff<-imaging.suff.stat(path.img.list = image.file,
                        path.mask.list = mask.file,
                        mpower = 1 #### denotes highest order moment wanted
    )
gc()#### I did this due to potential bug, 
```
  
suff\$mean will return the vector of column means, suff\$sd will return a vector of column standard deviations. These will be used in the next function, imaging.cp.mat(). This function we create the cross-product matrix we want to decompose. This matrix is based off of the center and scaled $X$ matrix.

```{r,echo=TRUE,cache=TRUE}
cp<-imaging.cp.mat(path.img.list = image.file,
                   path.mask.list = mask.file,
                   mean.vec = suff$mean,
                   sd.vec = suff$sd
  )
dim(cp)
```







